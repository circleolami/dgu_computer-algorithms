Q1. 
양의 정수 N을 입력 받은 후, 랜덤한 정수로 이루어진 크기 N의 정수 배열을 생성하세요. 
이후 이 배열에서 다음 세 가지 방법을 각각 이용하여 maximum subarray의 위치, 그 subarray가 포함하는 정수의 합, 그리고 사용된 비교 횟수를 출력하는 프로그램을 작성하세요. 
단, 동일한 합을 지니는 maximum subarray가 여러 개 존재할 때는 그 중에서 가장 왼쪽에서 시작하고, 시작점이 같다면 길이가 더 짧은 것이 출력되도록 하세요. 
- 방법 1. 모든 subarray에 대해 값을 조사하여 비교하는 Brute-force 방법
- 방법 2. Divide-and-Conquer 방식을 이용한 방법
- 방법 3. Dynamic programming (동적 프로그래밍) 방식을 이용한 방법 (Hint: rkddmlwkfy 26 페이지 참고)
N의크기를 늘려가며 각 방법에서 사용된 비교 횟수를 측정하고, 각 방법의 차이가 잘 나타나도록 결과를 그래프로 정리하세요. 

Q2. 
위 문제에서 정리한 방법을 토대로 Bruteforce 방법의 비교 횟수가 Divide-and-Conquer 방법의 비교 횟수보다 작거나 같아지는 가장 큰 입력 배열의 크기 n을 구하세요. 
이를 토대로 Divide-and-Conquer 방법을 적용한 recursive 알고리즘에서 base case가 n보다 작거나 같을 때는 Bruteforce 방식을 사용하도록 수정된 방법을 작성해보세요. 
이후, 이 방법과 기존 Divide-and-Conquer 방법의 필요 비교 횟수를 입력 크기 N에 대한 그래프로 정리하여 비교해보세요. 

Q3. 
(Activity-Selection) 양의 정수 입력 N을 입력 받은 후, 크기가 N이고, 랜덤한 양의 정수들로 이루어진 배열 s와 f를 다음 조건을 만족하도록 생성하세요. 
단, N > 10 이라 가정합니다. 
- 모든 0 <= i < N 에 대해 0 < f[i] - s[i] < 10 이고, 0 < s[i] < f[i] < N 
- 위 조건 외에 부가적인 조건을 추가하는 것은 안되고, 모든 s, f가 랜덤하게 생성되어야 한다. 
    (예를 들어, 단순히 모든 i에 대해 s[i] = i 이고, f[i] = s[i] + 1 이 되도록 구현하면 안된다.)
이제 이 배열을 각 강좌의 시간표로 생각하여 (s[i]: 강좌 i의 시작시간, f[i]: 강좌 i의 종료시간), 가장 많은 강좌를 시간이 겹치지 않도록 수강하는 방법을 출력하는 프로그램을 다음 두 가지 방법으로 각각 작성해보세요. 
- 방법 1. Dynamic Programming 방법 (Hint: 강의자료 31페이지)
- 방법 2. Greedy Algorithm 방법 (Hint: Greedy algorithm을 적용하기 위해서는 f[i]가 작은 수가 앞에 나오도록 정렬되어 있어야 한다. 
            현재 입력된 f[i]는 이를 만족하지 않으므로 먼저 정렬해주어야 한다. 하지만 이후 몇 번째 강좌를 수강하는지 출력해야 하므로, 단순히 f를 정렬하는 것은 안되고, 정렬 전/후의 정보를 잘 기록해 두어야 한다. s 또한 고려해야 한다.)
N의 크기를 늘려가며 각 방법에서 사용된 비교 횟수를 측정하고, 각 방법의 차이가 잘 나타나도록 결과를 그래프로 정리하시오. 