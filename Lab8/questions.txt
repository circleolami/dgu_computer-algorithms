Q1. 
다음 왼쪽 코드는 피보나치 수열을 구하는 재귀함수의 의사코드이다. 
또한, 오른쪽 코드는 피보나치 수열을 구하는 동적 알고리즘의 의사코드이다. 
각 의사코드에 1 이상의 정수 n을 입력하였을 때 출력되는 call의 횟수를 각각 예측하는 프로그램을 작성해보세요. 

- 왼쪽 코드
fib(n) {
    if (n == 1 or n == 2)
        print("call"); return 1;
    else
        return (fib(n-1) + fib(n-2));
}

 - 오른쪽 코드 
 MEMO-Fib(n){
    f[0..n] 배열 선언 // 피보나치 수 저장용 
    for i = 0 to n 
        f[i] = 0    // 0으로 초기화
return fib(n,f)

fib(n,f) {
    if(f[n]!=0) then return f[n];
    else {
        if (n = 1 or n = 2) then f[n] = 1;
        else {
            print("call")
            f[n] = fib(n-1, f) + fib(n-2, f);
        }
    return f;
    }
}

Q2. 
강의자료의 막대자르기 문제와 의사코드를 참고하여, 다음과 같은 두 가지 조건이 추가된 경우에 대해, 막대의 길이 n이 입력될 때, 이에 대한 최적의 해(가격 및 방법)을 구해주는 동적 프로그램을 작성하세요. 
    1) 막대를 한 번 자를 때마다 가공비가 2원씩 차감된다. 
        (예를 들어, 길이 2인 막대를 1짜리 막대 두 개로 나누어 판매할 경우, 총 판매 수입은 1+1-2 = 0이다.)
    2) 입력된 막대의 길이 n이 이하 주어진 막대 길이 별 가격보다 더 클 수 있으며, 길이가 10보다 큰 막대의 판매가격은 0원이다. 

Q3. 
강의자료의 LCS(Longest Commons Sequence) 찾기 문제와 의사코드를 참고하여, 다음을 각각 만족하는 동적알고리즘을 완성해보세요. 
    1) 길이가 각각 m, n인 두 string 입력에 대하여, b[i,j] 배열 (화살표 기록에 사욤함)을 사용하지 않고, O(m+n) 시간에 LCS를 복구해낸다.
    2) 하향식 방법(with memolzation)을 사용하여 문제를 해결한다. 
    3) 길이가 각각 m, n인 두 string 입력에 대하여, 크기가 최대 min(m, n)인 c[i, j] 배열 (최대 LCS 값 기록에 사용함)을 사용하여 LCS의 길이를 찾는다. 
소스코드에 주석을 통해 1) ~ 3)을 만족하고 있음을 설명하시오.  