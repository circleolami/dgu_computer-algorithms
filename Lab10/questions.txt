Q1. 
첫 줄에는 정점(vertex)의 개수, 간선(edge)의 개수, 탐색을 시작할 정점의 번호를 입력 받고, 다음 줄부터는 간선이 연결하는 두 정점의 번호가 주어진다. 
즉, 각 정점은 1부터 정점의 개수까지의 서로 다른 자연수로 번호가 매겨진다고 가정한다. 
그래프는 무방향(undirected) 그래프라 가정한다. 이렇게 입력 받은 정보를 인접리스트 형태로 저장한 후, DFS 탐색한 결과와 BFS로 탐색한 결과를 각각 출력하는 프로그램을 작성하세요. 
출력은 방문하는 정점의 번호를 순서대로 출력하면 된다. 

Q2. 
양의 정수 N과 실수 확률값 p (0<p<1)를 입력 받은 후, 이를 통해 행렬의 각 원소를 p의 확률로 1, 1-p의 확률로 0으로 생성하는 NxN 인접행렬을 생성하세요. 
단, 인접행렬은 반드시 대칭행렬이 되도록 생성해야 한다. (즉, i행 j열의 원소 = j행 i열의 원소).
이후 이 인접행렬을 1번에서 사용한 인접리스트 형태로 변환한 후 그래프가 총 몇 개의 연결성분(connected component)으로 이루어져 있는가를 출력하는 프로그램을 작성하세요. 
(Hint. 위에서 작성한 DFS 혹은 BFS 출력을 이용하면 한 연결 그래프에 포함된 점들을 모두 얻을 수 있다.)

Q3. 
2번 문제와 동일하게 양의 정수 N과 실수 확률값 p(0<p<1) 입력에 대해 그래프를 생성하는데, 행렬의 각 원소가 p의 확률로 1부터 10 사이의 랜덤한 자연수가 되고, 1-p의 확률로 inf값을 가지도록 한다. 
이후, 이를 최소한의 간선만 추가하여 하나의 연결 그래프로 변경하시오. 이후, 이 그래프에 대해 Minimum Spanning Tree를 출력하는 Prim의 알고리즘을 작성하세요. 
단, 그래프의 정점 수 V, 간선 수 E에 대해, 실행시간이 O(ElogV) 혹은 O(ElogE)가 되도록 작성해야 한다. 
간선의 수를 변화해가며 실행시간을 측정한 후, 이를 정리하여 보고서에 그래프(x축 E, y축 실행시간) 형태로 작성하세요. 