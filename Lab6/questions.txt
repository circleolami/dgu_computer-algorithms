Q1.
N (20000 >= N >= 1000)을 입력받고 rand() 함수를 이용하여 N개의 중복되지 않는 난수로 이루어진 데이터 배열을 만들고,
BSTInsert()를 이용하여 앞서 생성한 N개의 데이터를 순서대로 삽입하여 이진 탐색트리 T1을 만들어라.
그리고 T1 트리의 자료를 Inorder로 순회(Traversal)하면서 재배치시키고, 이를 입력으로 새로운 이진탐색 트리 T2와 Red-Black 트리 T3를 만드시오. 
그리고, 각각의 트리를 초기 구축하는데 소요된 '키의 평균 비교횟수'와 각각의 트리에서 랜덤한 100개의 자료들을 탐색(반드시 트리에 포함될 자료일 필요는 없음)하는데,
소요된 '키의 평균 비교횟수'를 구하고 아래의 출력 예제와 같이 출력하는 프로그램을 작성하시오.
또한, T2와 T3의 평균 비교횟수를 이용해 Red-Black 트리의 탐색 성능에 대해 논의하시오. 
(단, 삽입에 필요한 평균비교횟수는 각 자료 삽입을 위한 키의 비교횟수 합계를 구한 다음에 전체 자료수 N으로 나누어서 계산함)

Q2. 
N (20000 > N >= 1000)을 입력받고 rand() 함수를 이용하여 서로 다른 N개의 난수를 발생시켜 데이터 배열에 중복되는 값이 없도록 만들고,
그 배열 값을 1번 문제에서 작성한 Red-Black 트리 T3와 Hash Table에 각각 삽입해보세요. 
이때, Hash Table의 크기 M은 이하 규칙에 따라 설정, Red-Black 트리 T3와 Hash Table를 초기 구축하는데 소요된 '키의 평균 비교횟수'와 Red-Black 트리 T3와
Hash Table에서 100개의 자료들을 탐색하는데 소요된 '키의 평균 비교횟수를 구하고, 아래의 출력 예제와 같이 출력하는 프로그램을 작성하시오.
또한, T3와 Hash Table의 평균 비교횟수를 이용해 Hashing 방법의 탐색 성능에 대해 논의하시오. 
(단, Hash Table의 크기 M은 11, 101, 1009로 정하고, Hash 함수는 Division Method(HashValue = Key mod M)로, 충돌해결방법은 Chaining 방법을 이용해 각각 프로그램을 작성하시오.)

Q3. 
N (20000 > N >= 1000)를 입력 받아 임의의 문자열 N개를 생성하고 (각 문자열의 길이는 100 이하라고 가정),
강의자료 5페이지의 Hash 함수 두 개(implementation1, implementation3)와 본인이 Java hashCode를 참고하여 정의한 Hash를 각각 이용해 Hash Table에 삽입해보세요.
각 경우, Hash Table의 크기에 따라 hash 출력 값을 수정해주어야 합니다. 
Hash Table 크기 M =N/2, 충돌은 Chaining 방법으로 해결하세요. 
각 방법에서 임의로 100개의 데이터를 검색할 때 필요한 비교횟수를 출력하는 프로그램을 작성하고, 각 방법의 탐색 성능에 대해 논의해보세요. 